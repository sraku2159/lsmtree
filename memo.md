## メモ

* RwLockを使用すると、RwLockReadGuardとRwLockWriteGuardを使用して、読み取りと書き込みのロックを取得できます。
* RwLockは、複数のスレッドが同時に読み取りを行うことを許可し、書き込みは排他制御されます。
* これにより、読み取りと書き込みの競合を防ぎつつ、読み取りのパフォーマンスを向上させることができます。
* ただし、RwLockは、書き込みが発生すると、すべての読み取りがブロックされるため、書き込みが頻繁に発生する場合は、性能が低下する可能性があります。

対して、Mutexは、排他制御を行うためのロックであり、同時に1つのスレッドのみがロックを取得できます。
* Mutexは、書き込みと読み取りの両方を排他制御するため、RwLockよりも性能が低下する可能性があります。
* Mutexは、スレッド間での排他制御が必要な場合に使用されます。
* Mutexは、RwLockよりもシンプルなロックであり、使用が簡単です。
* Mutexは、スレッド間での排他制御が必要な場合に使用されます。

今回の場合は、RwLockを使用する方が適切なように思える。
なので、後でRwLockを使用するように修正する。


続いてコンパクションの処理に関して。
現在、スリープをコンパクションを行うスレッドが自ら行っているが、これを以下のように変更する。

* put内でsstaleにフラッシュする処理を行うスレッド内で、現在のsstableの情報を取得
* もし、閾値を越えたならコンパクションに`thread::unpark`を行う
* コンパクションを行うスレッドは、`thread::park`で待機する

ここで、メインスレッドで`thread::unpark`を行うわけではないので、`thread`を`Arc`でラップする必要がある。
`thread`は、`LSMTree`のフィールドとして初期化時に持つ

* 本来は、sstableやインデックスはフィクスチャーで持つべき
* 現在は、各テストでそれを行なってしまっている

* もう一つのトリガー方法として、`Condvar`を使用する方法がある。
* `Condvar`は、スレッド間での通知を行うための構造体であり、スレッドが待機している状態から通知を受けて再開することが可能
* これにより、スレッドを構造体で持つ必要がなくなる
* しかしこれは、クリティカルセクションとなるデータに対して、`Mutex`を使用する必要がある




* 現在、各`put`スレッドで`sstable`の数が閾値を超えた場合、`mspc::connection`を介してコンパクションスレッドにデータを渡すようにしているが、`send`と`recv`でデータの順番が保証されないため、正しく動作しない。
* これを解決するためには、閾値を超えた場合に通知のみを行い、コンパクションスレッドがデータを取得するようにする必要がある。
* 